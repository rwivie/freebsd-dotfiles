#include "signal-handler.h"

#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
#include <unistd.h>

#include "block.h"
#include "main.h"
#include "timer.h"

typedef struct {
    int signal;
} signal_info;

signal_handler signal_handler_new(
    block *const blocks, const unsigned short block_count,
    const signal_refresh_callback refresh_callback,
    const signal_timer_callback timer_callback) {
    signal_handler handler = {
        .refresh_callback = refresh_callback,
        .timer_callback = timer_callback,

        .blocks = blocks,
        .block_count = block_count,
    };

    return handler;
}

int signal_handler_init(signal_handler *const handler) {
    handler->fd = kqueue();
    if (handler->fd == -1) {
        perror("kqueue");
        return 1;
    }

    struct kevent ke;

    // Handle user-generated signal for refreshing the status.
    EV_SET(&ke, REFRESH_SIGNAL, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0, NULL);
    if (kevent(handler->fd, &ke, 1, NULL, 0, NULL) == -1) {
        perror("kevent");
        return 1;
    }

    // Handle SIGALRM generated by the timer.
    EV_SET(&ke, TIMER_SIGNAL, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0, NULL);
    if (kevent(handler->fd, &ke, 1, NULL, 0, NULL) == -1) {
        perror("kevent");
        return 1;
    }

    // Handle termination signals.
    EV_SET(&ke, SIGINT, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0, NULL);
    if (kevent(handler->fd, &ke, 1, NULL, 0, NULL) == -1) {
        perror("kevent");
        return 1;
    }

    EV_SET(&ke, SIGTERM, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0, NULL);
    if (kevent(handler->fd, &ke, 1, NULL, 0, NULL) == -1) {
        perror("kevent");
        return 1;
    }

    for (unsigned short i = 0; i < handler->block_count; ++i) {
        const block *const block = &handler->blocks[i];
        if (block->signal > 0) {
            EV_SET(&ke, SIGRTMIN + block->signal, EVFILT_SIGNAL, EV_ADD | EV_ENABLE, 0, 0, NULL);
            if (kevent(handler->fd, &ke, 1, NULL, 0, NULL) == -1) {
                fprintf(stderr, "error: invalid or unsupported signal specified for \"%s\" block\n", block->command);
                return 1;
            }
        }
    }

    // Block all realtime and handled signals.
    sigset_t set;
    sigemptyset(&set);
    for (int i = SIGRTMIN; i <= SIGRTMAX; ++i) {
        sigaddset(&set, i);
    }
    sigprocmask(SIG_BLOCK, &set, NULL);

    return 0;
}

int signal_handler_deinit(signal_handler *const handler) {
    if (close(handler->fd) != 0) {
        perror("close");
        return 1;
    }
    return 0;
}

int signal_handler_process(signal_handler *const handler, timer *const timer) {
    struct kevent ke;
    int nev = kevent(handler->fd, NULL, 0, &ke, 1, NULL);
    if (nev == -1) {
        perror("kevent");
        return 1;
    }

    const int signal = (int)ke.ident;
    switch (signal) {
        case TIMER_SIGNAL:
            if (handler->timer_callback(handler->blocks, handler->block_count, timer) != 0) {
                return 1;
            }
            return 0;
        case REFRESH_SIGNAL:
            if (handler->refresh_callback(handler->blocks, handler->block_count) != 0) {
                return 1;
            }
            return 0;
        case SIGTERM:
        case SIGINT:
            return 1;
    }

    for (unsigned short i = 0; i < handler->block_count; ++i) {
        block *const block = &handler->blocks[i];
        if (block->signal == signal - SIGRTMIN) {
            block_execute(block, 0); // Assuming button value is not needed
            break;
        }
    }

    return 0;
}
